% Exemple d'utilisation de la classe `thesul' pour un master.
% D. Roegel, 3/4/2013
%
% Note : les couvertures de Master ne sont pas finalisées dans thesul.
%        Indiquez-moi ce qu'il faut mettre.
%
\documentclass{thesul}

\usepackage{capt-of}
%\usepackage{lipsum}% just to generate text for the example
\usepackage{placeins}
\usepackage[toc,page]{appendix}
\usepackage{multirow}
\usepackage{xspace}
\usepackage{latexsym}

\usepackage{listings}

\usepackage{color}
\usepackage[T1]{fontenc}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{orange}{rgb}{1.0,0.49,0.0}

\lstset{frame=single,
  language={Java},
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  basicstyle={\small\ttfamily},
  numbers=left,
  stepnumber=1,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{orange},
  commentstyle=\color{dkgreen},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=1,
  morecomment=[l]{\\*},
  morekeywords={fair, process, macro, procedure, define, algorithm, variables}
}
\renewcommand{\floatpagefraction}{.99}
\renewcommand{\textfraction}{.01}

\newcommand{\tlaplus}{TLA\textsuperscript{+}\xspace}
\newcommand{\EXCEPT}{\textsc{except}}

%% make TeX use text italic font in math environments
\makeatletter
\newcounter{abr@ctr}
\newcommand{\abr@c}{\c@abr@ctr\advance\c@abr@ctr\@ne}

\DeclareSymbolFont{tlaitalics}{\encodingdefault}{cmr}{m}{it}
\let\itfam\symtlaitalics

\newcommand{\noTeXmath}{%
\c@abr@ctr=\itfam
\multiply\c@abr@ctr"100\relax
\advance\c@abr@ctr "7061\relax
\mathcode`a=\abr@c\mathcode`b=\abr@c\mathcode`c=\abr@c\mathcode`d=\abr@c
\mathcode`e=\abr@c\mathcode`f=\abr@c\mathcode`g=\abr@c\mathcode`h=\abr@c
\mathcode`i=\abr@c\mathcode`j=\abr@c\mathcode`k=\abr@c\mathcode`l=\abr@c
\mathcode`m=\abr@c\mathcode`n=\abr@c\mathcode`o=\abr@c\mathcode`p=\abr@c
\mathcode`q=\abr@c\mathcode`r=\abr@c\mathcode`s=\abr@c\mathcode`t=\abr@c
\mathcode`u=\abr@c\mathcode`v=\abr@c\mathcode`w=\abr@c\mathcode`x=\abr@c
\mathcode`y=\abr@c\mathcode`z=\abr@c
\c@abr@ctr=\itfam
\multiply\c@abr@ctr"100\relax
\advance\c@abr@ctr "7041\relax
\mathcode`A=\abr@c\mathcode`B=\abr@c\mathcode`C=\abr@c\mathcode`D=\abr@c
\mathcode`E=\abr@c\mathcode`F=\abr@c\mathcode`G=\abr@c\mathcode`H=\abr@c
\mathcode`I=\abr@c\mathcode`J=\abr@c\mathcode`K=\abr@c\mathcode`L=\abr@c
\mathcode`M=\abr@c\mathcode`N=\abr@c\mathcode`O=\abr@c\mathcode`P=\abr@c
\mathcode`Q=\abr@c\mathcode`R=\abr@c\mathcode`S=\abr@c\mathcode`T=\abr@c
\mathcode`U=\abr@c\mathcode`V=\abr@c\mathcode`W=\abr@c\mathcode`X=\abr@c
\mathcode`Y=\abr@c\mathcode`Z=\abr@c}

\newcommand{\TeXmath}{%
\mathcode`a="7161\mathcode`b="7162\mathcode`c="7163\mathcode`d="7164%
\mathcode`e="7165\mathcode`f="7166\mathcode`g="7167\mathcode`h="7168%
\mathcode`i="7169\mathcode`j="716A\mathcode`k="716B\mathcode`l="716C%
\mathcode`m="716D\mathcode`n="716E\mathcode`o="716F\mathcode`p="7170%
\mathcode`q="7171\mathcode`r="7172\mathcode`s="7173\mathcode`t="7174%
\mathcode`u="7175\mathcode`v="7176\mathcode`w="7177\mathcode`x="7178%
\mathcode`y="7179\mathcode`z="717A\mathcode`A="7141\mathcode`B="7142%
\mathcode`C="7143\mathcode`D="7144\mathcode`E="7145\mathcode`F="7146%
\mathcode`G="7147\mathcode`H="7148\mathcode`I="7149\mathcode`J="714A%
\mathcode`K="714B\mathcode`L="714C\mathcode`M="714D\mathcode`N="714E%
\mathcode`O="714F\mathcode`P="7150\mathcode`Q="7151\mathcode`R="7152%
\mathcode`S="7153\mathcode`T="7154\mathcode`U="7155\mathcode`V="7156%
\mathcode`W="7157\mathcode`X="7158\mathcode`Y="7159\mathcode`Z="715A}

\noTeXmath
\makeatother

\makeatletter
\newcommand*{\centerfloat}{%
  \parindent \z@
  \leftskip \z@ \@plus 1fil \@minus \textwidth
  \rightskip\leftskip
  \parfillskip \z@skip}
\makeatother

% -------------------------------------------------------------------
%                         Les références
%-------------------------------------------------------------------

\NoChapterNumberInRef
\NoChapterPrefix


\begin{document}

      \OddHead={{\leftmark\rightmark}{\hfil\slshape\rightmark}}
      \EvenHead={{\leftmark}{{\slshape\leftmark}\hfil}}
      \OddFoot={\hfil\thepage}
      \EvenFoot={\thepage\hfil}
      \pagestyle{ThesisHeadingsII}

%-------------------------------------------------------------------
%            Réinitialisation de la numérotation des chapitres
%-------------------------------------------------------------------

% Si la commande suivante est présente,
% elle doit figurer APRÈS \begin{document}
% et avant la première commande \part
\ResetChaptersAtParts 





\MasterUL
\ThesisTitle{Formal Verification of Distributed Algorithms using Distributed-PlusCal}
\ThesisAuthor{Heba Al-kayed}
\ThesisPresentedThe{soutenu le 23 septembre 2016}
\President    = {Le pr\'esident}
\Rapporteurs  = {Le rapporteur 1\\
                 Le rapporteur 2\\
                 Le rapporteur 3}
\Examinateurs = {L'examinateur 1\\
                 L'examinateur 2}

\MakeThesisTitlePage


%-------------------------------------------------------------------
%                          remerciements
%-------------------------------------------------------------------

%\DontFrameThisInToc
\begin{ThesisAcknowledgments}
Les remerciements.
\end{ThesisAcknowledgments}

%-------------------------------------------------------------------
%                            dédicace
%-------------------------------------------------------------------

\begin{ThesisDedication}
Je dédie cette thèse\\
à ma machine.\\
Oui, à Pandore,\\
qui fut la première de toutes.
\end{ThesisDedication}


%-------------------------------------------------------------------
%                  écriture de `Chapitre' et `Partie' 
%                      dans la table des matières
%-------------------------------------------------------------------

\WritePartLabelInToc
\WriteChapterLabelInToc

%-------------------------------------------------------------------
%                        table des matières
%-------------------------------------------------------------------

\tableofcontents

% Pour ne pas avoir le mot « Chapitre » au début de chaque chapitre.
\NoChapterHead


% La commande \mainmatter permet de passer
% à la numérotation arabe (ce que fait \pagenumbering{arabic}) 
% et de faire commencer la nouvelle page 1 sur une page impaire.
% On évitera donc d'utiliser directement \pagenumbering{arabic}.
\mainmatter


\chapter{Introduction}
%%============================

- Model checking is a verification method that is automatic and model-based(system is represented by a model, a specification is represented as a formula and we check whether the model satisfies the formula ==> if not we have counter models), it is intended to be used for concurrent systems.

- The purpose of a modeling language is to describe what a system must perform,
not how a system must perform.
- the users of these modeling languages are algorithm designers who
are responsible for describing the functionality of the system in terms of algorithms
before actual implementation. Thus, these languages should be simple so that the
users can learn and use the language constructs easily.

- PlusCal language by Leslie Lamport provides simple pseudo-code like interface
for the user to express concurrent systems.

- distributed system bugs are difficult to find by testing, they tend to be non-reproducible or not covered by test-cases.

- TLA+
- 

\chapter{Background info}
%%============================

This chapter is an overview of TLA+ and PlusCal.
\section{\tlaplus}
%%============================

\tlaplus is a formal specification language in which algorithms and systems can be described at a high level of abstraction and can be formally verified using the model checker TLC or the interactive proof assistant TLAPS. \tlaplus is based on mathematical set theory for describing data structures in terms of sets and functions, and on the Temporal Logic of Actions TLA for specifying their executions as state machines. \tlaplus specifications usually have the form
\[
  Init \land \Box[Next]_{vars} \land L
\]
where $Init$ is a predicate describing the possible initial states, $Next$ is a predicate that constrains the possible state transitions, $vars$ is the tuple of all state variables that appear in the specification, and $L$ is a liveness or fairness property expressed as a formula of temporal logic. Transition formulas such as $Next$, also called \emph{actions}, are at the core of \tlaplus, and represent instantaneous state changes. They contain unprimed state variables denoting the value of the variable before the transition as well as primed state variables that denote the value after the transition.

\begin{figure}
\begin{lstlisting}% [caption = A memory specification in \tlaplus., frame = tlrb, firstnumber =  1,label=memory-tla]

---------------------------- MODULE SimpleMemory ----------------------------
CONSTANTS Address, Value, InitValue, NoValue

ASSUME 
  /\ InitValue \in Value
  /\ NoValue \notin Value

VARIABLES chan, mem

\* initial condition
Init == 
  /\ chan = NoValue
  /\ mem = [a \in Address |-> InitValue]

\* transitions: reading and writing
Read(a) == 
  /\ chan' = mem[a]
  /\ mem' = mem

Write(a,v) ==
  /\ mem' = [mem EXCEPT ![a] = v]
  /\ chan' = NoValue

Next ==
  \/ \E a \in Address : Read(a)
  \/ \E a \in Address, v \in Value : Write(a,v)

\* overall specification
Spec == Init /\ [][Next]_<<chan,mem>>

\* predicate specifying type correctness
TypeOK == 
  /\ chan \in Value \cup {NoValue}
  /\ mem \in [Address -> Value] 
=============================================================================
\end{lstlisting}
\caption{A memory specification in \tlaplus.}
\label{memory-tla}
\end{figure}

For example, figure~\ref{memory-tla} shows a \tlaplus specification of a simple memory. It declares four constant parameters $Address$, $Value$, $InitValue$, and $NoValue$, and states a hypothesis on the values that these parameters can be instantiated with. The state space of the specification is represented by the two variables $chan$ and $mem$. Intuitively, $mem$ holds the current memory, whereas $chan$ is an output channel that reflects the result of the preceding operation.

The remainder of the \tlaplus module contains operator definitions that represent parts of the specification and of correctness properties. The state predicate $Init$ fixes the initial values of the two variables. The actions $Read(a)$ and $Write(a,v)$ represent reading the value at memory address $a$ and writing value $v$ to memory address $a$, respectively. In this specification, the memory is modeled as a function mapping addresses to values. The \tlaplus expression $[x \in S \mapsto e]$ denotes the function with domain $S$ such that every element $x$ of $S$ is mapped to $e$. This is reminiscent of a $\lambda$-expression but also makes explicit the domain of the function. Function application $f[x]$ is written using square brackets. Finally, the expression $[f\ \EXCEPT\ ![x] = e]$ denotes the function that is similar to $f$, except that argument $x$ is mapped to $e$, one can think of it as a function overwrite.

The action $Next$ defines the possible state transitions as the disjunction of $Read$ and $Write$ actions, and $Spec$ represents the overall specification of the memory.

\tlaplus is an untyped language. Type correctness can be verified as a property of the specification. For our example, the predicate $TypeOK$ indicates the possible values that the variables $chan$ and $mem$ are expected to hold at any state of the specification. Formally, the implication $Spec \Rightarrow \Box TypeOK$ can be established as a theorem.

\bigskip

\hfill\\

For More details on the syntax and grammer of TLA+, see \ref{tlabook}.

\section{PlusCal algorithm language}
%%============================

\tlaplus is a specification formalism not a programming language, in order for a user to incorporate it properly the user must possess knowledge about mathematical set theory, this is uncustomary among users who write programs and algorithms, Thus PlusCal was proposed to accompany TLA+, for the reason that PlusCal used conventional program constructs.

An algorithm language is used to focus on aspects of the algorithm such as data manipulation rather than irrelevant and distracting details that involve programming-language objects and data structures.

PlusCal is an algorithm language that describes both concurrent and sequential algorithms, it maintains the powerful expressiveness of \tlaplus as well as representing atomicity conveniently.

The TLA+ Toolbox provides a platform where algorithm designers can model their algorithms using PlusCal, translate them to the corresponding TLA+ specifications and check for the algorithm's correctness through the TLC model checker.

A PlusCal algorithm is located in a comment statement within the tla file, the general structure of a PlusCal algorithm is shown in Figure \ref{pluscal-struct}.

\begin{figure}[!h]
\begin{lstlisting}% [caption = General structure of a PlusCal algorithm, frame = tlrb, firstnumber =  1,label=pluscal-struct]

(* algorithm <algorithm name>

(* Declaration section *)
variables <variable declarations>

(* Definition section *)
define <definition name> == <definition description>

(* Macro section *)
macro <name>(var1, ...)
 <macro-body of statements>

(* Procedure section *)
procedure <name>(arg1, ...)
 variables <local variable declarations>
 <procedure body of statements>

(* Processes section *)
process (<name> [=|\in] <Expr>))
  variables <variable declarations>
  <process body of statements>


***********************)

\end{lstlisting}
\caption{General structure of a PlusCal algorithm}
\label{pluscal-struct}
\end{figure}

The \textbf{Declaration section} is where the user declares global variables that are shared among all the components of the algorithm. The \textbf{Definition section} allows the user to write TLA+ definitions of operators that depend on the algorithm's global variables.
The \textbf{Macro section} holds macros whose bodies are expanded at translation time incorporating the parameters passed from the calling statement, macros have the same expansion behavior as C pre-processing macros. \textbf{Procedure} in PlusCal take a number of arguments, can define their own local variables and can modify the global variables, however they have no return value.A \textbf{Process} begins in one of two ways: 
\begin{center}
$process (ProcName \in IdSet)$ \\
$process (ProcName = Id)$

\end{center}

The first form begins a process set, the second an individual process. these statements are optionally followed by declaration of local variables. The process body is a sequence of statements, Within the body of a process set, $self$ equals the current process's identifier.

All PlusCal statements must be within a label, where statements within the same label are executed atomically.
PlusCal enforces a strict ordering of its blocks. The define block has to come before any macros, which has to come before any procedures, which has to come before any processes. The full grammar of the PlusCal algorithm language can be found at appendix A of the PlusCal manual[\cite{pcalAlgo}].

The Figure \ref{semaphoreEx} shows the modeling of a semaphore mutex example in PlusCal, Semaphores are integer variables that are used to solve the critical section problem.
 
\begin{figure}[!h]

\begin{lstlisting}[frame = tlrb, firstnumber = 1]
(*
--algorithm SemaphoreMutex{
variables sem = 1;

process(p \in 1..N)
{
 start : while (TRUE){
            enter : when (sem > 0);
                 sem := sem - 1;            
            cs    : skip ;
            exit  : sem := sem + 1 ;
        }
 }
}
*)

\end{lstlisting}
\caption{Semaphore mutex example in PlusCal}
\label{semaphoreEx}
\end{figure} 
\hfill\\

\textbf{The translation process} is carried out by the compiler  expecting the structure we described as well as some semantic rules, for instance the first statement of any process or procedure as this statement marks the starting point of that entity, and macros are not allowed to contain any labels since all the statements in the body are executed as a part of the same atomic step.

The compiler generates the translation by carrying on the following tasks:
\begin{enumerate}

\item Generate all the definitions and variables regardless of their scope within the PlusCal algorithm, as well as $vars$ the tuple of all variables.

\begin{figure}[!h]
\begin{lstlisting}[frame = tlrb, firstnumber = 1,xleftmargin=.2\textwidth, xrightmargin=.2\textwidth]
\* BEGIN TRANSLATION
VARIABLES sem, pc

vars == << sem, pc >>

\end{lstlisting}
\caption{Translation of definitions and variables}
\label{genDefAndVar}
\end{figure} 

\item Generate $ProcSet$ which is a set that contains all the process identifiers.

\begin{figure}[!h]
\begin{lstlisting}[frame = tlrb, firstnumber = 1,xleftmargin=.2\textwidth, xrightmargin=.2\textwidth]
ProcSet == (1..N)

\end{lstlisting}
\caption{Generate $ProcSet$}
\label{GenProcSet}
\end{figure} 

\item  Generate $Init$, the initial predicate that specifies the initial values of all the declared variables. Comments indicate if the variables are global or local to a process or procedure.
The translator produces a variable $pc$ that is defined and used as a program control variable, it's a function whose domain is $ProcSet$ such that each element is mapped to the predicate that represents the entry point of execution for the process.

\begin{figure}[!h]
\begin{lstlisting}[frame = tlrb, firstnumber = 1, xleftmargin=.2\textwidth, xrightmargin=.2\textwidth]
Init == (* Global variables *)
        /\ sem = 1
        /\ pc = [self \in ProcSet |-> "st"]

\end{lstlisting}

\caption{Generate $Init$}
\label{GenInit}
\end{figure} 


\item Define a \tlaplus action for each atomic operation of the algorithm. In the produced actions unprimed variables refer to their values before executing the action and the primed variables refer to their values after the execution.
The definition is parameterized by the identifier self ,
which represents the current process’s identifier.
The $pc$ variable is used to indicate the navigation between the actions for a process.

\begin{figure}[!h]
\centering
\begin{lstlisting}[frame = tlrb, firstnumber = 1]
st(self) == /\ pc[self] = "st"
            /\ pc' = [pc EXCEPT ![self] = "enter"]
            /\ UNCHANGED sem

enter(self) == /\ pc[self] = "enter"
               /\ (sem > 0)
               /\ sem' = sem - 1
               /\ pc' = [pc EXCEPT ![self] = "cs"]

cs(self) == /\ pc[self] = "cs"
            /\ TRUE
            /\ pc' = [pc EXCEPT ![self] = "exit"]
            /\ UNCHANGED sem

exit(self) == /\ pc[self] = "exit"
              /\ sem' = sem + 1
              /\ pc' = [pc EXCEPT ![self] = "st"]
              
p(self) == st(self) \/ enter(self) \/ cs(self) \/ exit(self)

\end{lstlisting}
\caption{Translation of PlusCal labels into TLA+}
\label{GenActions}
\end{figure} 

\item Generate the next-state action $Next$ and the complete specification $Spec$.

\begin{figure}[!h]
\begin{lstlisting}[frame = tlrb, firstnumber = 1, xleftmargin=.2\textwidth, xrightmargin=.2\textwidth]
Next == (\E self \in 1..N: p(self))

Spec == Init /\ [][Next]_vars

\end{lstlisting}

\caption{Generate $Next$ and $Spec$}
\label{GenNextSpec}
\end{figure} 

\end{enumerate}

\hfill\\
The overall translation strategy can be found \cite{pcalAlgo}.

\chapter{Related work}
%%============================

- pluscal extensions for generation code to make sure thatverified spec isn't lost while being implemented
- \ref{PGO} a tool represented as a part of a master thesis, it aims to produce an implementation in Go(C based language developed by Google) based on a PlusCal/TLA+ specification.

\section{PGO}

PGo is a source to source compiler written in Java. It compiles specifications written in an extension of PlusCal, called Modular PlusCal to Go programs, PGo can compile Modular PlusCal to PlusCal, PlusCal to Go, and Modular PlusCal to Go.

\subsection{Modular PlusCal}

Modular PlusCal is an extension of PlusCal, using Modular PlusCal the user can separate the specification into two components, a system functionality specification concerned with what the algorithm is supposed to achieve and an environment specification concerned about how we may want it achieved.

\hfill\\

For example, if we consider a server/client based communication system, the system functionality can be a client requesting services, this is called system functionality, which is not related to how the client is requesting that service via a TCP connection for example, this is called an environment specification. Another added value for this separation is that the programmer can reuse concept defined in one specification in another specification since the environment specification isn't dependent on the functionality of the system.

Modular PlusCal introduced Architypes, Mapping Macros, and Instances to achieve the modularization of the spec.

\paragraph{\textbf{Architypes}}
\hfill\\
They are considered to be the blue print of a PlusCal process, they are used to specify the system behaviors. They have the same semantics except for the inability to access global variables unless passed to the architypes as arguments.

Using the \textit{ref} keyword before a global variable that is sent as an argument lets us know that this architype can modify it.

these restrictions provide the needed isolation between system and environment behaviours.

\paragraph{Mapping Macros}

They specify the environment, they define interfaces for reading and writing on a global variable that represents a network.
like pluscal macros they cannot contain any labels inside them, all statements are apart of the same step.

Modeling mapping macros independently from system functionality allows the user to reuse the mapping macros.

\paragraph{Instances}

Instances are the glue that holds the archtypes and mapping macros together.
instantiates a process or a group of processes using the specified architype, each argument passed is bound with a mapping macro to control read and write functions on it.

- show a smaller example or grammer

\chapter{Distributed PlusCal}

Distributed PlusCal is an extension of PlusCal, they are algorithm languages meant for writing algorithms not programs. they are both translated to TLA+. 

Since distributed algorithms are based on continuous interactions among components, they benefit greatly from testing failure conditions like deadlocks or race conditions at early stages of development at design level, and TLA+ provides a flexibility and an expressiveness that makes it able to specify and verify those algorithms. One of the popular examples of incorporating TLA+ to verify distributed algorithms is its usage at Amazon Web Services \cite{amazon}.

Our motivations for creating Disrtibuted PlusCal are quite similar to the motivations that created PlusCal, we wanted a syntax that would spare the user from having to model primitives that usually accompany distributed algorithms such as sub-processes and communication channels.

Since we extended the existing PluCal translator responsible for parsing PlusCal into TLA+ we inherited the same semantics and grammar and added our own which can be found in the figure below.

\begin{figure}[!h]

$\langle$ Process $\rangle$ $\models$ \textit{process} ($\langle$ variable decleration $\rangle$)$\langle$ local-variables $\rangle$ 
$\langle$ body $\rangle$\{$\langle$ body $\rangle$\}

$\langle$ local-variables $\rangle$ $\models$ \O  
|\textit{variables} $\langle$declaration-list$\rangle$ 
|\textit{channels} $\langle$declaration-list$\rangle$ 
|\textit{FIFOs} $\langle$declaration-list$\rangle$ 

$\langle$ declaration-list $\rangle$ $\models$ 
$\langle$ variable-declaration $\rangle$ | 
$\langle$ variable-declaration $\rangle$, $\langle$ decleration-list$\rangle$

$\langle$ body $\rangle$ $\models$ 
$\langle$ labeled-statement-list $\rangle$

\caption{Grammar for Distributed PlusCal}

\end{figure}

\hfill\\
In the sections that follow we will be explaining what we implemented, why it is needed and how it is translated into TLA+, for this we will be doing a walk-through on the two phase commit example, the two phase commit is a protocol used for distributed transactions that consist of multiple operations, performed at multiple sites, the goal of it is to reach consensus between the different elements that carry out the transaction together such that if an element decides to abort all other elements abort as well and the transaction is rolled back, and in order to actually commit all elements must agree and be able to commit.

\section{Communication Channels}

PlusCal enables the user to define variables with TLA+ syntax, the variable types can be sets, sequence, sequence of sets etc, 

- differentiate sets and sequences and mentions the operators of each with small examples


\subsection{channels}
-set based 
example with it's translation
\subsection{FIFO channels}
-sequence based
example with it's translation
\subsection{Supported channel functions}
expected syntax and limitations
- send, receive, broadcast, multicast, clear
\section{Sub-Processes}

A PlusCal process has a block that holds the body of the process, Distributed PlusCal gives each process the opportunity to define more than one block where each block has a body of labeled statements, This enables the process to be executing multiple tasks in parallel, for example a sub-process can be used to send date to other processes while another sub-process can be responsible for receiving data asynchronously, the programmer can divide tasks between sub-processes and give a sub-process a theme  if needed, that is by dividing the algorithm into multiple sub-processes where each sub-process works independently, this is to some extent a form of modularization.

//i've tried saying this modularization thing in different ways by now not sure if the idea is clear or if this is even a 'big deal' for modeling a spec!

// more on the benefits of this for distributed algorithms especially

\hfill\\
The body of a sub-process maintains the same syntax as the body of a PlusCal process, all the sub-processes share the same variables declared for the process, this makes communication between them possible if needed.

The example below shows the sub-processes are defined for the two phase commit algorithm, the example is written in c-syntax and the sub-processes are surrounded by curly braces.

\hfill\\\hfill\\
\begin{lstlisting}[caption = Distributed PlusCal Sub-Processes, frame = tlrb, firstnumber = 1]
    
(* PlusCal options (-distpcal) *)

(***
--algorithm TPC {
 
  \* message channels
  channels coord, agt[Agent];
     
  fair process (a \in Agent)
  variable aState = "unknown"; {

a1: if (aState = "unknown") {
        with(st \in {"accept", "refuse"}) {
          aState := st;
          send(coord, [type |-> st, agent |-> self]);
        };
    };
    a2: await(aState \in {"commit", "abort"})
    
  } {
    
    a3:await (aState # "unknown");
       receive(agt[self], aState); 
       
    a4:clear(agt);
  }

  fair process (c = Coord) 
  variables cState = "unknown",
            commits = {}, msg = {};
             \* agents that agree to commit
  {
    c1: await(cState \in {"commit", "abort"});    
        broadcast(agt, [ag \in Agent|-> cState]);
  } {
        
     c2:while (cState \notin {"abort", "commit"}) {
        receive(coord, msg);
            if (msg.type = "refuse") {
                cState := "abort";
            }
            else if (msg.type = "accept") {
                commits := commits \cup {msg.agent};
                 if (commits = Agent) {
                    cState := "commit";
                 }
              }
        }
  }
 }
***)
\end{lstlisting}

\hfill\\

The first process consists of two sub-processes, the first one contains the labels (a1, a2) and the second one contains (a3, a4).

//The send, receive and clear and broadcast would've been explained already //in the previous section.

The variable \textit{aState} is shared between the sub-processes, in fact it is used for communication between them, label a2 holds an \textit{await} statement at line 19 that is waiting for aState to have the value of either \textit{"commit"} or \textit{"abort"}, the variable is being set to one of these values by a3 in the second sub-process by the receive function at line 24.

it's important to note that the sub-processes do not allow variable declarations they only use variables declared for the entire process.

\subsection{TLA+ Translation}

Defining sub-processes had some effects on the translation to TLA+, because when you declare sub-processes you are actually partitioning the process, so now whenever we are referring to a process we need to know not only which process it is but also which sub-process are we referring to.
 
The entire TLA+ translation of the two phase commit example can be found in appendix \ref{appendix:examples}, now we will be focusing on elements that we introduced to the general structure of the TLA+ file.

\hfill\\
\begin{itemize}

\item \textbf{SubProcSet}
\hfill\\

SubProcSet is the set of all the sub-process identifiers per process.

\begin{lstlisting}[caption = TLA+ translation for Sub-Processes, frame = tlrb, firstnumber = 1]

ProcSet == (Agent) \cup {Coord}

SubProcSet == [n \in ProcSet |-> IF n \in Agent THEN 1..2
                             ELSE (**Coord**) 1..2]

\end{lstlisting}

\item \textbf{pc variable}
\hfill\\

The \textit{pc} variable in TLA+ that is used to indicate the current point of execution and the next statement to be executed with respect to a process, now it has to indicate also which sub-process is involved.
 	
The pc variable is initialized to a sequence of actions depending on the type of the process, for example if \textit{self} is in Agent, this means it's a process of type Agent that has the following actions associated with it (a1, a2, a3, a4), However, a1 is considered the entry point for the first sub-process and a3 for the second one. so we need to initialize pc variable to look something like this

\hfill\\
\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
\textbf{Process Type} & \textbf{Sub-Process} & \textbf{Entry Point} \\
\hline
Agent & 1 & a1 \\ 
		& 2 & a3 \\ 
\hline
Coord & 1 & c1 \\ 
	  & 2 & c2 \\ 
\hline
\end{tabular}
\end{center}

\hfill\\

In TLA+ a function with domain 1..n for some n in Nat is a sequence, so the pc values consist of sequences to represent the above table, so we initialize pc in the listing 4.3 to have pc[Agent] = <"a1", "a3"> and pc[Coord] = <"c1", "c2">.

//sequences and sets would've been explained in the previous section for the channels

\begin{lstlisting}[caption = TLA+ translation for Sub-Processes, frame = tlrb, firstnumber = 1]

Init == (* Global variables *)
        /\ coord = {}
        /\ agt = [a0 \in Agent |-> {}]
        (* Node a *)
        /\ aState = [self \in Agent |-> "unknown"]
        (* Node c *)
        /\ cState = "unknown"
        /\ commits = {}
        /\ msg = {}
        /\ pc = [self \in ProcSet |-> CASE self \in Agent -> <<"a1","a3">>
                                        [] self = Coord -> <<"c1","c2">>]
\end{lstlisting}

\hfill\\
The example in listing 4.4 shows how the \textit{pc} variable is used, the second pair of brackets that is added when accessing the \textit{pc} variable is used to indicate the sub-process, at line 3 we check that the sub-process is currently at this action, then at line 10 we specify that the next action to be executed for the sub-process is action a2.

\begin{lstlisting}[caption = TLA+ translation for Sub-Processes, frame = tlrb, firstnumber = 1]

\* Process 1 Sub-Process 1 : an action with the statements in a1 label
a1(self) == /\ pc[self] [1] = "a1"
            /\ IF aState[self] = "unknown"
                  THEN /\ \E st \in {"accept", "refuse"}:
                            /\ aState' = [aState EXCEPT ![self] = st]
                            /\ coord' = (coord \cup {[type |-> st, agent |-> self]})
                  ELSE /\ TRUE
                       /\ UNCHANGED << coord, aState >>
            /\ pc' = [pc EXCEPT ![self] = [@  EXCEPT ![1] = "a2"]]
            /\ UNCHANGED << agt, cState, commits, msg >>

\end{lstlisting}

\end{itemize}

\hfill\\

\chapter{Code Documentation}

\section{general structure of the toolbox and it's components}
try to describe the general flow

\section{parsing and expansion process}

\section{some software-based diagram}

or maybe an AST description graph

\chapter{Conclusion and future work}

\begin{appendices}
\chapter{Distributed PlusCal to TLA+ Examples}
\section{Two Phase Commit}
\label{appendix:examples}

\begin{lstlisting}[caption = TLA+ translation for Sub-Processes, frame = tlrb, firstnumber = 1]

----------------------------- MODULE 2pc -----------------------------
EXTENDS Sequences, Naturals

CONSTANTS Coord, Agent

State == {"unknown", "accept", "refuse", "commit", "abort"}

    
(* PlusCal options (-distpcal) *)

(***
--algorithm TPC {
 
  \* message channels
  channels coord, agt[Agent];
     
  fair process (a \in Agent)
  variable aState = "unknown"; {

a1: if (aState = "unknown") {
        with(st \in {"accept", "refuse"}) {
          aState := st;
          send(coord, [type |-> st, agent |-> self]);
        };
    };
    a2: await(aState \in {"commit", "abort"})
    
  } {
    
    a3:await (aState # "unknown");
       receive(agt[self], aState); 
       
    a4:clear(agt);
  }

  fair process (c = Coord) 
  variables cState = "unknown",
            commits = {}, msg = {};
             \* agents that agree to commit
  {
    c1: await(cState \in {"commit", "abort"});    
        broadcast(agt, [ag \in Agent|-> cState]);
  } {
        
     c2:while (cState \notin {"abort", "commit"}) {
        receive(coord, msg);
            if (msg.type = "refuse") {
                cState := "abort";
            }
            else if (msg.type = "accept") {
                commits := commits \cup {msg.agent};
                 if (commits = Agent) {
                    cState := "commit";
                 }
              }
        }
  }
 }
***)
\* BEGIN TRANSLATION
VARIABLES coord, agt, pc, aState, cState, commits, msg

vars == << coord, agt, pc, aState, cState, commits, msg >>

ProcSet == (Agent) \cup {Coord}

SubProcSet == [n \in ProcSet |-> IF n \in Agent THEN 1..2
                             ELSE (**Coord**) 1..2]

Init == (* Global variables *)
        /\ coord = {}
        /\ agt = [a0 \in Agent |-> {}]
        (* Node a *)
        /\ aState = [self \in Agent |-> "unknown"]
        (* Node c *)
        /\ cState = "unknown"
        /\ commits = {}
        /\ msg = {}
        /\ pc = [self \in ProcSet |-> CASE self \in Agent -> <<"a1","a3">>
                                        [] self = Coord -> <<"c1","c2">>]

a1(self) == /\ pc[self] [1] = "a1"
            /\ IF aState[self] = "unknown"
                  THEN /\ \E st \in {"accept", "refuse"}:
                            /\ aState' = [aState EXCEPT ![self] = st]
                            /\ coord' = (coord \cup {[type |-> st, agent |-> self]})
                  ELSE /\ TRUE
                       /\ UNCHANGED << coord, aState >>
            /\ pc' = [pc EXCEPT ![self] = [@  EXCEPT ![1] = "a2"]]
            /\ UNCHANGED << agt, cState, commits, msg >>

a2(self) == /\ pc[self] [1] = "a2"
            /\ (aState[self] \in {"commit", "abort"})
            /\ pc' = [pc EXCEPT ![self] = [@  EXCEPT ![1] = "Done"]]
            /\ UNCHANGED << coord, agt, aState, cState, commits, msg >>

a3(self) == /\ pc[self] [2] = "a3"
            /\ (aState[self] # "unknown")
            /\ \E a1519 \in agt[self]:
                 /\ aState' = [aState EXCEPT ![self] = a1519]
                 /\ agt' = [agt EXCEPT ![self] = agt[self] \ {a1519}]
            /\ pc' = [pc EXCEPT ![self] = [@  EXCEPT ![2] = "a4"]]
            /\ UNCHANGED << coord, cState, commits, msg >>

a4(self) == /\ pc[self] [2] = "a4"
            /\ agt' = [a0 \in Agent |-> {}]
            /\ pc' = [pc EXCEPT ![self] = [@  EXCEPT ![2] = "Done"]]
            /\ UNCHANGED << coord, aState, cState, commits, msg >>

a(self) == a1(self) \/ a2(self) \/ a3(self) \/ a4(self)

c1 == /\ pc[Coord] [1] = "c1"
      /\ (cState \in {"commit", "abort"})
      /\ agt' = [ag \in Agent |-> agt[ag] \cup  {cState} ]
      /\ pc' = [pc EXCEPT ![Coord] = [@  EXCEPT ![1] = "Done"]]
      /\ UNCHANGED << coord, aState, cState, commits, msg >>

c2 == /\ pc[Coord] [2] = "c2"
      /\ IF cState \notin {"abort", "commit"}
            THEN /\ \E c1512 \in coord:
                      /\ coord' = coord \ {c1512}
                      /\ msg' = c1512
                 /\ IF msg'.type = "refuse"
                       THEN /\ cState' = "abort"
                            /\ UNCHANGED commits
                       ELSE /\ IF msg'.type = "accept"
                                  THEN /\ commits' = (commits \cup {msg'.agent})
                                       /\ IF commits' = Agent
                                             THEN /\ cState' = "commit"
                                             ELSE /\ TRUE
                                                  /\ UNCHANGED cState
                                  ELSE /\ TRUE
                                       /\ UNCHANGED << cState, commits >>
                 /\ pc' = [pc EXCEPT ![Coord] = [@  EXCEPT ![2] = "c2"]]
            ELSE /\ pc' = [pc EXCEPT ![Coord] = [@  EXCEPT ![2] = "Done"]]
                 /\ UNCHANGED << coord, cState, commits, msg >>
      /\ UNCHANGED << agt, aState >>

c == c1 \/ c2

(* Allow infinite stuttering to prevent deadlock on termination. *)
Terminating == /\ \A self \in ProcSet : \A sub \in SubProcSet[self]: pc[self][sub] = "Done"
               /\ UNCHANGED vars

Next == c
           \/ (\E self \in Agent: a(self))
           \/ Terminating

Spec == /\ Init /\ [][Next]_vars
        /\ \A self \in Agent : WF_vars(a(self))
        /\ WF_vars(c)

Termination == <>(\A self \in ProcSet: \A sub \in SubProcSet[self] : pc[self][sub] = "Done")

\* END TRANSLATION
=============================================================================

\end{lstlisting}

In the translation above, every label is transformed into an action, some actions are also created when needed, for example the receive function and the clear function in process 1 sub-process 2 both modify the same channel and it would be wrong to place the two assignments in the same atomic step thus an auxiliary action is created to hold the body of the clear function.

- insert labels in example, before await and also for receive and clear then modify the example


\section{Lamport Mutex}

\end{appendices}

\bibliographystyle{alpha}
\bibliography{report}

\end{document}
